// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package Tema2_ISP_CTD;

import java.util.*; 


/************************************************************/
/**
 **
 */
public class DispVerificare extends Date_Rovinieta {
	
	/**
	 * Practic, un index care retine cate roviniete au fost verificate pana acum.
	 */
	private int nrRoviniete;
	/**
	 * Camp care retine rovinietele verificate de dispozitiv pana acum.
	 * Functioneaza ca un istoric al dispozitivului
	 */
	private Rovinieta[] rovinieta;
	
	/**
	 * Camp care retine cele mai apropiate sectii de politie, impreuna cu distantele
	 *  relative de la dispozitiv pana la acestea.
	 */
	private HashMap<String, Integer> distante = new HashMap<String, Integer>();
	
	/**
	 * Camp print care dispozitivul de verificare comunica cu "baza de date"
	 */
	Evidenta evidenta;
	
	/**
	 * Camp prin care disp de verificare comunica cu camera
	 */
	CanalComunicatie canal = null;
	
	/**
	 * In acest string se va pastra numarul de inmatriculare returnat de canal
	 */
	String date;
	
	/**
	 * Constructor de baza
	 */
	public DispVerificare() {
		nrRoviniete =0;
		rovinieta =null;
		evidenta =new Evidenta();
		distanteDefault();
	}
	
	/**
	 * Constructori in care putem introduce noi parametrii din cod
	 */
	public DispVerificare(CanalComunicatie can)
	{
		this.canal = can;
		nrRoviniete =0;
		rovinieta =null;
		evidenta =new Evidenta();
		distanteDefault();
	}
	
	public DispVerificare(Rovinieta[] roviniete, int lungime) {
		nrRoviniete = lungime;
		if(roviniete != null) {
			for(int i=0; i<nrRoviniete; ++i)
				rovinieta[i] = roviniete[i];
		}
		evidenta =new Evidenta();
		distanteDefault();
		canal = new CanalComunicatie();
	}
	
	public DispVerificare(Rovinieta[] roviniete, int lungime, CanalComunicatie can) {
		nrRoviniete = lungime;
		if(roviniete != null) {
			for(int i=0; i<nrRoviniete; ++i)
				rovinieta[i] = roviniete[i];
		}
		evidenta =new Evidenta();
		distanteDefault();
		this.canal = can;
	}
	
	/**
	 * Metoda care adauga niste valori predefinite (de test) pentru campul de distante
	 */
	public void distanteDefault() {
		distante.put("Bucuresti", 30); 
		distante.put("Ploiesti", 15); 
		distante.put("Constanta", 25); 
		distante.put("Bld 1 Mai", 70); 
		distante.put("Bld Stefan cel Mare", 56); 
	}
	
	/**
	 * Getteri si Setteri
	 */
	public Rovinieta getRovinieta(int i) 
	{
		return rovinieta[i];
	}
	
	public Rovinieta[] getRovinieta()
	{
		return rovinieta;
	}

	public void setRovinieta(Rovinieta[] rovinieta, int lungime) 
	{
		rovinieta = new Rovinieta[lungime];
		nrRoviniete =0;
		
		for(int i=0; i < lungime; ++i) {
			this.rovinieta[i] = rovinieta[i];
			nrRoviniete = nrRoviniete +1;
		}
	}
	
	public int getNrRoviniete() {
		return nrRoviniete;
	}
	
	public Evidenta getEvidenta() {
		return evidenta;
	}
	
	public void setEvidenta(Evidenta evid) {
		
		int nr = evid.getNrRoviniete();
		evidenta.setNrRoviniete(nr);
		for(int i=0; i<nr; ++i) {
			Rovinieta temp = evid.getRovinieta(i);
			evidenta.setRovinieta(temp, i);
		}
	}
	
	public HashMap<String, Integer> getDistante(){
		return distante;
	}

	public void setDistante(HashMap<String, Integer> dist) {
		if(dist != null) {
			distante.clear();
			distante.putAll(dist);
		}
	}
	
	public void setCanal(CanalComunicatie can) {
		canal = can;
	}
	
	public CanalComunicatie getCanal() {
		return canal;
	}
	
	public String getDate()
	{
		if(date != null || date != "") return date;
		return "";
	}
	
	public void setDate(String date) {
		this.date = date;
	}
	
	
	/**
	 * Metoda care verifica distantele fata de toate statiile de politie din vecinatate si o alege pe cea mai apropiata
	 * Ea este impartita in 3 etape: sortarea locatiilor dupa distanta, alegerea locatiei cele mai apropiate si transmiterea
	 *  acesteia catre metoda de alertarePolitie
	 */
	public boolean verificareProximitatePolitie() {
		if(!distante.isEmpty()) {
			// sortarea locatiilor dupa distanta fata de dispozitiv
			HashMap<String, Integer> dist= new HashMap<String, Integer>();
			dist.putAll(distante);
			distante = sortByValue(dist);   // sorteaza hashmap-ul in functie de valoarea distantelor fata de dispozitiv
			
			// alegerea celei mai apropiate locatii
			Map.Entry<String,Integer> entry = distante.entrySet().iterator().next();
			String key = entry.getKey();       // cheia pentru prima valoare din hashmap
			Integer value = entry.getValue();  // prima valoarea din hashmap
			
			// transmiterea informatiilor catre metoda de alertarePolitie
			System.out.println("Departamentul este " + key);
			alertarePolitie(key, value);
			return true;
		}
		else return false;
	}
	
	/**
	 * Metoda care se ocupa de sortarea HashMap-ului de distante
	 */
	public HashMap<String, Integer> sortByValue(HashMap<String, Integer> dist) {
		// Creaza o lista din elementele HashMap-ului
        List<Map.Entry<String, Integer> > list = 
               new LinkedList<Map.Entry<String, Integer> >(dist.entrySet()); 
  
        // Sorteaza lista
        Collections.sort(list, new Comparator<Map.Entry<String, Integer> >() { 
            public int compare(Map.Entry<String, Integer> o1,  
                               Map.Entry<String, Integer> o2) 
            { 
                return (o1.getValue()).compareTo(o2.getValue()); 
            } 
        }); 
        
        // Retine lista intr-o variabila temporara
        HashMap<String, Integer> temp = new LinkedHashMap<String, Integer>(); 
        for (Map.Entry<String, Integer> aa : list) { 
            temp.put(aa.getKey(), aa.getValue()); 
        } 
        
        // transmite informatiile sortate
        return temp;
	}
	
	
	/**
	 * Metoda care se ocupa identificarea seriei de sasiu asociate unui numar de inmatriculare 
	 *  identificat de dispozitivul de identificare.
	 * Aceasta verifica, de asemenea, daca numarul de inmatriculare exista si daca seria de sasiu 
	 *  asociata este legitima, inainte de terminarea executiei
	 * 
	 * Daca una din aceste verificari esueaza, datele sunt transmise catre metoda de verificareRovinieta
	 */
	public boolean preluareDateRovinieta(String nrInmatriculare) {
		String serieSasiu = "";
		if(evidenta.rovinietaExista(nrInmatriculare, "inmatr")) 
			if(evidenta.getSerieSasiu(nrInmatriculare) != "nimic") {
				serieSasiu = evidenta.getSerieSasiu(nrInmatriculare);
				return true;
			}
			
		System.out.println("Datele sunt in proces de verificare...");
		verificareRovinieta(nrInmatriculare, serieSasiu);
		return false;
	}
	
	/**
	 * Aceasta metoda verifica daca o rovinieta exista sau daca este expirata. Daca una din aceste conditii 
	 *  nu este indeplinita, politia va fi alertata.
	 * De asemenea, in timpul rularii, rezultatul intors de metoda este trimis catre decodificareSemnal pentru
	 * 	interpretarea rezultatului intors de metoda
	 */
	@Override
	public int verificareRovinieta(String nrInmatriculare, String serieSasiu) {
		
		Rovinieta temp = new Rovinieta(nrInmatriculare, serieSasiu);
		if(evidenta.rovinietaExista(serieSasiu, "sasiu")) {
			if(evidenta.rovinietaExpirata(serieSasiu) == false) {
				System.out.println("Date confirmate! Conduceti cu grija!");
				this.adaugaRovinieta(temp);
				decodificareSemnal(1);
				return 1;
			} else {
				System.out.println("Rovinieta expirata! Inceperea procesului de alertare politie!");
				verificareProximitatePolitie();
				decodificareSemnal(2);
				return 2;}
		} 
		System.out.println("Rovinieta incorecta! Inceperea procesului de alertare politie!");
		verificareProximitatePolitie();
		decodificareSemnal(3);
		return 3;
	}
	
	/**
	 * Identificarea mesajului transmis de metoda verificareRovinieta. Scop principal: debugging
	 * @param temp = semnalul primit ca parametru
	 */
	public boolean decodificareSemnal(int temp) {
		if(temp == 1) return true;
		else if (temp == 2 || temp == 3) return false;
		return false;
	}
	
	/**
	 * Metoda care trimite un semnal de alarma catre cea mai apropiata sectie de politie, in legatura 
	 *  cu o rovinieta necorespunzatoare, identificata de una din camerele de politie
	 * Detaliile celei mai apropiate sectii de politie sunt primite ca si parametru
	 */
	public boolean alertarePolitie(String departament, int distanta) {
		if(distanta > 0) {
			System.out.println("Statia de politie " + departament + " a fost alertata!");
			System.out.println("Aceasta se afla la distanta de " + distanta + "km de locatia acestui dispozitiv.");
			
			Organ_politie politist = new Organ_politie();
			politist.primireSemnal(departament);
			return true;
		}
		return false;
	}
	
	/**
	 * Verific daca dispozitivul s a conectat la canalul de comunicatie
	 */
	public boolean verificareConnectareDispozitiv() {
		if(this.canal != null ) {
			System.out.println("Conectare reusita");
			return true;
		}
		System.out.println("Eroare de conectare a Dispozitivului de Verificare la Canal");
		return false;
	}
	
	/**
	 * Se salveaza in Stringul date informatiile de pe canalul de comunicatie
	 */
	public boolean acceptareDate () {
		String captareDate = canal.transmitereDate();
		if(this.canal != null && (captareDate != null || captareDate != "")) {
			this.date = captareDate;
			System.out.println(this.date);
			this.preluareDateRovinieta(date);
			return true;
		}
		return false;
	}
	
	/**
	 * Metode suplimentare pentru controlul campului de roviniete dintr-un obiect tip dispozitiv de verificare
	 */
	public boolean adaugaRovinieta(Rovinieta rovinieta) 
	{
		if(evidenta.rovinietaExista(rovinieta.getNrInmatriculare(), "inmatr"))
			if(nrRoviniete > 1) {
				
				nrRoviniete = nrRoviniete +1; 
				Rovinieta temp[] = new Rovinieta[nrRoviniete]; 
				
				for(int i=0; i<nrRoviniete-1; ++i)
					temp[i] = this.rovinieta[i];
				
				temp[nrRoviniete-1] = rovinieta;
				
				this.rovinieta = new Rovinieta[nrRoviniete];
				
				for(int i=0; i<nrRoviniete; ++i)
					this.rovinieta[i] = temp[i];
				return true;
			} 
			else if(nrRoviniete == 1)
			{
				nrRoviniete = nrRoviniete +1;
				Rovinieta temp = this.rovinieta[nrRoviniete-2];
				
				this.rovinieta = new Rovinieta[nrRoviniete]; //marit spatiul la 2
				this.rovinieta[nrRoviniete -2] = temp;       // pe 0 punem temp
				this.rovinieta[nrRoviniete -1] = rovinieta;  // pe 1 punem rovinieta pe care o vrem
				return true;
			} 
			else if(nrRoviniete == 0){
				nrRoviniete = nrRoviniete +1;
				this.rovinieta = new Rovinieta[nrRoviniete]; //aloc 1 spatiu
				this.rovinieta[nrRoviniete-1] = rovinieta;   // pun pe pozitia 1-1=0 pe rovinieta
				return true;
			} 
			else return false;
		else return false;
	}
	
	public boolean scoateRovinieta(Rovinieta rovinieta) {
		boolean ok=false;
		for(int i=0; i<nrRoviniete; ++i) {
			if(ok) {
				this.rovinieta[i-1] = this.rovinieta[i];
			}
			if(this.rovinieta[i] == rovinieta)
				ok=true;
		}
		if(ok) {
			nrRoviniete = nrRoviniete -1;
			return true;
		}
		else return false;
	}
	
	public boolean scoateRovinieta(int numar) {
		if(numar < nrRoviniete) {
			for(int i=numar+1; i<nrRoviniete; ++i) {
				this.rovinieta[i-1] = this.rovinieta[i];
			}
			return true;
		}
		else return false;
	}
	
	/**
	 * Metoda care afiseaza continului campului de distante, de tip HashMap
	 */
	public void afiseazaDist() {
		for (String name: distante.keySet()){
        String key = name;
        Integer value = distante.get(name);  
        System.out.println(key + " " + value);  
} 
	}
	
	/**
	 * Metoda care afiseaza continutul campului de roviniete verificate de dispozitiv pana in prezent.
	 */
	public void listaRoviniete() {
		
		if(nrRoviniete == 0)
	 		return;
		
		for(int i=0; i<nrRoviniete; ++i)
			rovinieta[i].afisareDate();
	}
	
};